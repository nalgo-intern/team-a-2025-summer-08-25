STL(Standard Template Library)を使っていこう！

c++の安パイな設定
#include <iostream>
#include <string>
#include <utility>
#include <limits.h>
#include <algorithm>
#include <iomanip>
#include <math.h>
#include <queue>
#include <stack>
#include <list>
#include <map>
#include <set>
#define rep(i,n) for(int i = 0; i < (int)(n); i++)
using namespace std;
using llint = long long;
using vec = vector<llint>;
using vvec = vector<vec>;
using P = pair<llint, llint>;
#define INF 9e18


○基本的なループ構文の使い分け
　配列の全ての要素に対する処理を行なう場合 → 範囲for文
　それ以外で一定回数繰り返し処理する場合 → for文
　それ以外の場合 → while文

○変数を作成（オーバーロード）
  int equation(int a,int b);（ほかの変数に変更可）

  int equation(int a,int b) {
    return 2 * a + b; 
 }
 
メイン関数　（関数呼び出し）
  int a = equation(10,10);
 

○変数を作成（テンプレート）
  template <class T>
 T equation(T a = 0, T b = 0);

 template <class T>
 T equation(T a, T b) {
     return 2 * a + b;
 }


○配列vectorについて
　配列変数の末尾に追加。
　　配列変数名.push_back();
　配列変数の末尾を削除
　　配列変数名.pop_back();

○c++に内蔵されている関数について
    min(a,b);
    max(a,b);
    swap(a,b);

       変数aと変数bの値を交換する
          sort(vec.begin(),vec.end());
       配列変数vecをソートする
           reverse(vec.begin(),vec.end());
       配列変数vecの要素の並びを逆にする

○vectorの配列すべてを出力する処理（範囲for文）
　　for (配列の要素の型 変数名 : 配列変数) {
  　　// 各要素に対する処理
　　}
　範囲for文はコンテナというデータ型に使用することができる。（string型はコンテナ）

○vectorによる多次元配列
　宣言：vector<vector<要素の型>> 変数名(要素数1, vector<要素の型>(要素数2, 初期値))　　（初期化は省略可能）
　i行目j列目へのアクセス　
　  　変数名.at(i).at(j)
　縦の大きさの取得
　　　変数名.size()
　横の大きさの取得
           変数名.at(0).size()

○参照について（関数の結果を複数返すときにとても便利）
　参照の宣言
　　参照先の型 &参照の名前 = 参照先;

○int で２億よりも大きい数を扱う場合
　　int64_t 
　　数値LL

○Double型の数をcoutで桁数を指定して出力する場合
　　cout << fixed << setprecision(桁数);

○キャスト（型の変換方法）
　　（型）値
　　※int型からstring型への変更不可


〇pair
    pair<型, 型> 変数名　= make_pair(数値、数値);

〇pairを用いたvector
    vector<pair<型,型>> 変数名(要素数);
〇queue
    queue<型>　変数名;

〇priority_queue（値は大きい順位取り出される）
    priority_queue<型> 変数名;

〇priority_queue（値は小さい順に取り出される）
    priority_queue<型, vector<型>, greater<型>> 変数名;

〇map　ーーー宣言ーーー
    map<Keyの型, Valueの型> 変数名;

〇map　ーーー値の追加ーーー
    変数[key] = value;

〇map 　ーーー値の削除ーーー
    変数.erase(key);

〇map　 ーーーアクセスーーー
    変数.at(key)  //keyに対応するvalueが存在しない場合はエラーになる
    変数[key]     //keyに対応するvalueが存在しない場合はvalueの型の初期値が追加される
    []はバグの原因になるので注意

〇map 　ーーー所属判定ーーー
    if(変数.count(key)){
        //keyに対応する関係が存在する。
    }　else {
        //keyに対応する関係が存在しない。
    }

// Keyの値が小さい順にループ
for (auto p : 変数名) {
  auto key = p.first;
  auto value = p.second;
  // key, valueを使う
}


〇map ーーーループ処理ーーー
// Keyの値が小さい順にループ
for (pair<Keyの型, Valueの型> p : 変数名) {
  Keyの型 key = p.first;
  Valueの型 value = p.second;
  // key, valueを使う
}

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

二分探索
https://pyteyon.hatenablog.com/entry/2019/02/20/194140#stdbinary_search

int mid;
    int start;
    int last;
    for (int i = 0; i < Q; i++) {
        start = 0;
        last = N;
        while (true) {
            mid = (last + start) / 2;
            if (A[mid] >= X[i]) {
                last = mid;
            } else if (A[mid] < X[i]) {
                start = mid + 1;
            } 
            //cout << "start " << start << " last " << last << " mid" << mid << endl;
            if (last == start) {
                cout << N - start << endl;
                break;
            }


        }
    }